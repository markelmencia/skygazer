{
  "version": 3,
  "sources": ["../../ol/DataTile.js", "../../ol/structs/LRUCache.js", "../../ol/renderer/canvas/TileLayer.js", "../../ol/layer/TileProperty.js", "../../ol/layer/BaseTile.js", "../../ol/layer/Tile.js"],
  "sourcesContent": ["/**\n * @module ol/DataTile\n */\nimport Tile from './Tile.js';\nimport TileState from './TileState.js';\nimport {createCanvasContext2D} from './dom.js';\n\n/**\n * @typedef {HTMLImageElement|HTMLCanvasElement|HTMLVideoElement|ImageBitmap} ImageLike\n */\n\n/**\n * @typedef {Uint8Array|Uint8ClampedArray|Float32Array|DataView} ArrayLike\n */\n\n/**\n * Data that can be used with a DataTile.\n * @typedef {ArrayLike|ImageLike} Data\n */\n\n/**\n * @param {Data} data Tile data.\n * @return {ImageLike|null} The image-like data.\n */\nexport function asImageLike(data) {\n  return data instanceof Image ||\n    data instanceof HTMLCanvasElement ||\n    data instanceof HTMLVideoElement ||\n    data instanceof ImageBitmap\n    ? data\n    : null;\n}\n\n/**\n * @param {Data} data Tile data.\n * @return {ArrayLike|null} The array-like data.\n */\nexport function asArrayLike(data) {\n  return data instanceof Uint8Array ||\n    data instanceof Uint8ClampedArray ||\n    data instanceof Float32Array ||\n    data instanceof DataView\n    ? data\n    : null;\n}\n\n/**\n * This is set as the cancellation reason when a tile is disposed.\n */\nexport const disposedError = new Error('disposed');\n\n/**\n * @type {CanvasRenderingContext2D|null}\n */\nlet sharedContext = null;\n\n/**\n * @param {ImageLike} image The image.\n * @return {Uint8ClampedArray} The data.\n */\nexport function toArray(image) {\n  if (!sharedContext) {\n    sharedContext = createCanvasContext2D(\n      image.width,\n      image.height,\n      undefined,\n      {willReadFrequently: true},\n    );\n  }\n  const canvas = sharedContext.canvas;\n  const width = image.width;\n  if (canvas.width !== width) {\n    canvas.width = width;\n  }\n  const height = image.height;\n  if (canvas.height !== height) {\n    canvas.height = height;\n  }\n  sharedContext.clearRect(0, 0, width, height);\n  sharedContext.drawImage(image, 0, 0);\n  return sharedContext.getImageData(0, 0, width, height).data;\n}\n\n/**\n * @type {import('./size.js').Size}\n */\nconst defaultSize = [256, 256];\n\n/**\n * @typedef {Object} Options\n * @property {import(\"./tilecoord.js\").TileCoord} tileCoord Tile coordinate.\n * @property {function(): Promise<Data>} loader Data loader.  For loaders that generate images,\n * the promise should not resolve until the image is loaded.\n * @property {number} [transition=250] A duration for tile opacity\n * transitions in milliseconds. A duration of 0 disables the opacity transition.\n * @property {boolean} [interpolate=false] Use interpolated values when resampling.  By default,\n * the nearest neighbor is used when resampling.\n * @property {import('./size.js').Size} [size=[256, 256]] Tile size.\n * @property {AbortController} [controller] An abort controller.\n * @api\n */\n\nclass DataTile extends Tile {\n  /**\n   * @param {Options} options Tile options.\n   */\n  constructor(options) {\n    const state = TileState.IDLE;\n\n    super(options.tileCoord, state, {\n      transition: options.transition,\n      interpolate: options.interpolate,\n    });\n\n    /**\n     * @type {function(): Promise<Data>}\n     * @private\n     */\n    this.loader_ = options.loader;\n\n    /**\n     * @type {Data}\n     * @private\n     */\n    this.data_ = null;\n\n    /**\n     * @type {Error}\n     * @private\n     */\n    this.error_ = null;\n\n    /**\n     * @type {import('./size.js').Size|null}\n     * @private\n     */\n    this.size_ = options.size || null;\n\n    /**\n     * @type {AbortController|null}\n     * @private\n     */\n    this.controller_ = options.controller || null;\n  }\n\n  /**\n   * Get the tile size.\n   * @return {import('./size.js').Size} Tile size.\n   */\n  getSize() {\n    if (this.size_) {\n      return this.size_;\n    }\n    const imageData = asImageLike(this.data_);\n    if (imageData) {\n      return [imageData.width, imageData.height];\n    }\n    return defaultSize;\n  }\n\n  /**\n   * Get the data for the tile.\n   * @return {Data} Tile data.\n   * @api\n   */\n  getData() {\n    return this.data_;\n  }\n\n  /**\n   * Get any loading error.\n   * @return {Error} Loading error.\n   * @api\n   */\n  getError() {\n    return this.error_;\n  }\n\n  /**\n   * Load the tile data.\n   * @api\n   * @override\n   */\n  load() {\n    if (this.state !== TileState.IDLE && this.state !== TileState.ERROR) {\n      return;\n    }\n    this.state = TileState.LOADING;\n    this.changed();\n\n    const self = this;\n    this.loader_()\n      .then(function (data) {\n        self.data_ = data;\n        self.state = TileState.LOADED;\n        self.changed();\n      })\n      .catch(function (error) {\n        self.error_ = error;\n        self.state = TileState.ERROR;\n        self.changed();\n      });\n  }\n\n  /**\n   * Clean up.\n   * @override\n   */\n  disposeInternal() {\n    if (this.controller_) {\n      this.controller_.abort(disposedError);\n      this.controller_ = null;\n    }\n    super.disposeInternal();\n  }\n}\n\nexport default DataTile;\n", "/**\n * @module ol/structs/LRUCache\n */\n\nimport Disposable from '../Disposable.js';\nimport {assert} from '../asserts.js';\n\n/**\n * @typedef {Object} Entry\n * @property {string} key_ Key.\n * @property {Entry|null} newer Newer.\n * @property {Entry|null} older Older.\n * @property {*} value_ Value.\n */\n\n/**\n * @classdesc\n * Implements a Least-Recently-Used cache where the keys do not conflict with\n * Object's properties (e.g. 'hasOwnProperty' is not allowed as a key). Expiring\n * items from the cache is the responsibility of the user.\n *\n * @fires import(\"../events/Event.js\").default\n * @template T\n */\nclass LRUCache {\n  /**\n   * @param {number} [highWaterMark] High water mark.\n   */\n  constructor(highWaterMark) {\n    /**\n     * Desired max cache size after expireCache(). If set to 0, no cache entries\n     * will be pruned at all.\n     * @type {number}\n     */\n    this.highWaterMark = highWaterMark !== undefined ? highWaterMark : 2048;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.count_ = 0;\n\n    /**\n     * @private\n     * @type {!Object<string, Entry>}\n     */\n    this.entries_ = {};\n\n    /**\n     * @private\n     * @type {?Entry}\n     */\n    this.oldest_ = null;\n\n    /**\n     * @private\n     * @type {?Entry}\n     */\n    this.newest_ = null;\n  }\n\n  deleteOldest() {\n    const entry = this.pop();\n    if (entry instanceof Disposable) {\n      entry.dispose();\n    }\n  }\n\n  /**\n   * @return {boolean} Can expire cache.\n   */\n  canExpireCache() {\n    return this.highWaterMark > 0 && this.getCount() > this.highWaterMark;\n  }\n\n  /**\n   * Expire the cache. When the cache entry is a {@link module:ol/Disposable~Disposable},\n   * the entry will be disposed.\n   * @param {!Object<string, boolean>} [keep] Keys to keep. To be implemented by subclasses.\n   */\n  expireCache(keep) {\n    while (this.canExpireCache()) {\n      this.deleteOldest();\n    }\n  }\n\n  /**\n   * FIXME empty description for jsdoc\n   */\n  clear() {\n    while (this.oldest_) {\n      this.deleteOldest();\n    }\n  }\n\n  /**\n   * @param {string} key Key.\n   * @return {boolean} Contains key.\n   */\n  containsKey(key) {\n    return this.entries_.hasOwnProperty(key);\n  }\n\n  /**\n   * @param {function(T, string, LRUCache<T>): ?} f The function\n   *     to call for every entry from the oldest to the newer. This function takes\n   *     3 arguments (the entry value, the entry key and the LRUCache object).\n   *     The return value is ignored.\n   */\n  forEach(f) {\n    let entry = this.oldest_;\n    while (entry) {\n      f(entry.value_, entry.key_, this);\n      entry = entry.newer;\n    }\n  }\n\n  /**\n   * @param {string} key Key.\n   * @param {*} [options] Options (reserved for subclasses).\n   * @return {T} Value.\n   */\n  get(key, options) {\n    const entry = this.entries_[key];\n    assert(\n      entry !== undefined,\n      'Tried to get a value for a key that does not exist in the cache',\n    );\n    if (entry === this.newest_) {\n      return entry.value_;\n    }\n    if (entry === this.oldest_) {\n      this.oldest_ = /** @type {Entry} */ (this.oldest_.newer);\n      this.oldest_.older = null;\n    } else {\n      entry.newer.older = entry.older;\n      entry.older.newer = entry.newer;\n    }\n    entry.newer = null;\n    entry.older = this.newest_;\n    this.newest_.newer = entry;\n    this.newest_ = entry;\n    return entry.value_;\n  }\n\n  /**\n   * Remove an entry from the cache.\n   * @param {string} key The entry key.\n   * @return {T} The removed entry.\n   */\n  remove(key) {\n    const entry = this.entries_[key];\n    assert(\n      entry !== undefined,\n      'Tried to get a value for a key that does not exist in the cache',\n    );\n    if (entry === this.newest_) {\n      this.newest_ = /** @type {Entry} */ (entry.older);\n      if (this.newest_) {\n        this.newest_.newer = null;\n      }\n    } else if (entry === this.oldest_) {\n      this.oldest_ = /** @type {Entry} */ (entry.newer);\n      if (this.oldest_) {\n        this.oldest_.older = null;\n      }\n    } else {\n      entry.newer.older = entry.older;\n      entry.older.newer = entry.newer;\n    }\n    delete this.entries_[key];\n    --this.count_;\n    return entry.value_;\n  }\n\n  /**\n   * @return {number} Count.\n   */\n  getCount() {\n    return this.count_;\n  }\n\n  /**\n   * @return {Array<string>} Keys.\n   */\n  getKeys() {\n    const keys = new Array(this.count_);\n    let i = 0;\n    let entry;\n    for (entry = this.newest_; entry; entry = entry.older) {\n      keys[i++] = entry.key_;\n    }\n    return keys;\n  }\n\n  /**\n   * @return {Array<T>} Values.\n   */\n  getValues() {\n    const values = new Array(this.count_);\n    let i = 0;\n    let entry;\n    for (entry = this.newest_; entry; entry = entry.older) {\n      values[i++] = entry.value_;\n    }\n    return values;\n  }\n\n  /**\n   * @return {T} Last value.\n   */\n  peekLast() {\n    return this.oldest_.value_;\n  }\n\n  /**\n   * @return {string} Last key.\n   */\n  peekLastKey() {\n    return this.oldest_.key_;\n  }\n\n  /**\n   * Get the key of the newest item in the cache.  Throws if the cache is empty.\n   * @return {string} The newest key.\n   */\n  peekFirstKey() {\n    return this.newest_.key_;\n  }\n\n  /**\n   * Return an entry without updating least recently used time.\n   * @param {string} key Key.\n   * @return {T|undefined} Value.\n   */\n  peek(key) {\n    return this.entries_[key]?.value_;\n  }\n\n  /**\n   * @return {T} value Value.\n   */\n  pop() {\n    const entry = this.oldest_;\n    delete this.entries_[entry.key_];\n    if (entry.newer) {\n      entry.newer.older = null;\n    }\n    this.oldest_ = /** @type {Entry} */ (entry.newer);\n    if (!this.oldest_) {\n      this.newest_ = null;\n    }\n    --this.count_;\n    return entry.value_;\n  }\n\n  /**\n   * @param {string} key Key.\n   * @param {T} value Value.\n   */\n  replace(key, value) {\n    this.get(key); // update `newest_`\n    this.entries_[key].value_ = value;\n  }\n\n  /**\n   * @param {string} key Key.\n   * @param {T} value Value.\n   */\n  set(key, value) {\n    assert(\n      !(key in this.entries_),\n      'Tried to set a value for a key that is used already',\n    );\n    const entry = {\n      key_: key,\n      newer: null,\n      older: this.newest_,\n      value_: value,\n    };\n    if (!this.newest_) {\n      this.oldest_ = entry;\n    } else {\n      this.newest_.newer = entry;\n    }\n    this.newest_ = entry;\n    this.entries_[key] = entry;\n    ++this.count_;\n  }\n\n  /**\n   * Set a maximum number of entries for the cache.\n   * @param {number} size Cache size.\n   * @api\n   */\n  setSize(size) {\n    this.highWaterMark = size;\n  }\n}\n\nexport default LRUCache;\n", "/**\n * @module ol/renderer/canvas/TileLayer\n */\nimport DataTile, {asImageLike} from '../../DataTile.js';\nimport ImageTile from '../../ImageTile.js';\nimport TileRange from '../../TileRange.js';\nimport TileState from '../../TileState.js';\nimport {ascending} from '../../array.js';\nimport {\n  containsCoordinate,\n  createEmpty,\n  equals,\n  getIntersection,\n  getRotatedViewport,\n  getTopLeft,\n  intersects,\n} from '../../extent.js';\nimport {fromUserExtent} from '../../proj.js';\nimport ReprojTile from '../../reproj/Tile.js';\nimport {toSize} from '../../size.js';\nimport LRUCache from '../../structs/LRUCache.js';\nimport {createOrUpdate as createTileCoord, getKeyZXY} from '../../tilecoord.js';\nimport {\n  apply as applyTransform,\n  compose as composeTransform,\n} from '../../transform.js';\nimport {getUid} from '../../util.js';\nimport CanvasLayerRenderer from './Layer.js';\n\n/**\n * @param {import(\"../../source/Tile.js\").default} source The tile source.\n * @param {string} sourceKey The source key.\n * @param {number} z The tile z level.\n * @param {number} x The tile x level.\n * @param {number} y The tile y level.\n * @return {string} The cache key.\n */\nfunction getCacheKey(source, sourceKey, z, x, y) {\n  return `${getUid(source)},${sourceKey},${getKeyZXY(z, x, y)}`;\n}\n\n/**\n * @typedef {Object<number, Set<import(\"../../Tile.js\").default>>} TileLookup\n */\n\n/**\n * Add a tile to the lookup.\n * @param {TileLookup} tilesByZ Lookup of tiles by zoom level.\n * @param {import(\"../../Tile.js\").default} tile A tile.\n * @param {number} z The zoom level.\n * @return {boolean} The tile was added to the lookup.\n */\nfunction addTileToLookup(tilesByZ, tile, z) {\n  if (!(z in tilesByZ)) {\n    tilesByZ[z] = new Set([tile]);\n    return true;\n  }\n  const set = tilesByZ[z];\n  const existing = set.has(tile);\n  if (!existing) {\n    set.add(tile);\n  }\n  return !existing;\n}\n\n/**\n * Remove a tile from the lookup.\n * @param {TileLookup} tilesByZ Lookup of tiles by zoom level.\n * @param {import(\"../../Tile.js\").default} tile A tile.\n * @param {number} z The zoom level.\n * @return {boolean} The tile was removed from the lookup.\n */\nfunction removeTileFromLookup(tilesByZ, tile, z) {\n  const set = tilesByZ[z];\n  if (set) {\n    return set.delete(tile);\n  }\n  return false;\n}\n\n/**\n * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n * @param {import(\"../../extent.js\").Extent} extent The frame extent.\n * @return {import(\"../../extent.js\").Extent} Frame extent intersected with layer extents.\n */\nfunction getRenderExtent(frameState, extent) {\n  const layerState = frameState.layerStatesArray[frameState.layerIndex];\n  if (layerState.extent) {\n    extent = getIntersection(\n      extent,\n      fromUserExtent(layerState.extent, frameState.viewState.projection),\n    );\n  }\n  const source = /** @type {import(\"../../source/Tile.js\").default} */ (\n    layerState.layer.getRenderSource()\n  );\n  if (!source.getWrapX()) {\n    const gridExtent = source\n      .getTileGridForProjection(frameState.viewState.projection)\n      .getExtent();\n    if (gridExtent) {\n      extent = getIntersection(extent, gridExtent);\n    }\n  }\n  return extent;\n}\n\n/**\n * @typedef {Object} Options\n * @property {number} [cacheSize=512] The cache size.\n */\n\n/**\n * @classdesc\n * Canvas renderer for tile layers.\n * @api\n * @template {import(\"../../layer/Tile.js\").default|import(\"../../layer/VectorTile.js\").default} [LayerType=import(\"../../layer/Tile.js\").default<import(\"../../source/Tile.js\").default>|import(\"../../layer/VectorTile.js\").default]\n * @extends {CanvasLayerRenderer<LayerType>}\n */\nclass CanvasTileLayerRenderer extends CanvasLayerRenderer {\n  /**\n   * @param {LayerType} tileLayer Tile layer.\n   * @param {Options} [options] Options.\n   */\n  constructor(tileLayer, options) {\n    super(tileLayer);\n\n    options = options || {};\n\n    /**\n     * Rendered extent has changed since the previous `renderFrame()` call\n     * @type {boolean}\n     */\n    this.extentChanged = true;\n\n    /**\n     * The last call to `renderFrame` was completed with all tiles loaded\n     * @type {boolean}\n     */\n    this.renderComplete = false;\n\n    /**\n     * @private\n     * @type {?import(\"../../extent.js\").Extent}\n     */\n    this.renderedExtent_ = null;\n\n    /**\n     * @protected\n     * @type {number}\n     */\n    this.renderedPixelRatio;\n\n    /**\n     * @protected\n     * @type {import(\"../../proj/Projection.js\").default|null}\n     */\n    this.renderedProjection = null;\n\n    /**\n     * @protected\n     * @type {!Array<import(\"../../Tile.js\").default>}\n     */\n    this.renderedTiles = [];\n\n    /**\n     * @private\n     * @type {string}\n     */\n    this.renderedSourceKey_;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.renderedSourceRevision_;\n\n    /**\n     * @protected\n     * @type {import(\"../../extent.js\").Extent}\n     */\n    this.tempExtent = createEmpty();\n\n    /**\n     * @private\n     * @type {import(\"../../TileRange.js\").default}\n     */\n    this.tempTileRange_ = new TileRange(0, 0, 0, 0);\n\n    /**\n     * @type {import(\"../../tilecoord.js\").TileCoord}\n     * @private\n     */\n    this.tempTileCoord_ = createTileCoord(0, 0, 0);\n\n    const cacheSize = options.cacheSize !== undefined ? options.cacheSize : 512;\n\n    /**\n     * @type {import(\"../../structs/LRUCache.js\").default<import(\"../../Tile.js\").default>}\n     * @private\n     */\n    this.tileCache_ = new LRUCache(cacheSize);\n\n    this.maxStaleKeys = cacheSize * 0.5;\n  }\n\n  /**\n   * @return {LRUCache} Tile cache.\n   */\n  getTileCache() {\n    return this.tileCache_;\n  }\n\n  /**\n   * Get a tile from the cache or create one if needed.\n   *\n   * @param {number} z Tile coordinate z.\n   * @param {number} x Tile coordinate x.\n   * @param {number} y Tile coordinate y.\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @return {import(\"../../Tile.js\").default|null} Tile (or null if outside source extent).\n   * @protected\n   */\n  getOrCreateTile(z, x, y, frameState) {\n    const tileCache = this.tileCache_;\n    const tileLayer = this.getLayer();\n    const tileSource = tileLayer.getSource();\n    const cacheKey = getCacheKey(tileSource, tileSource.getKey(), z, x, y);\n\n    /** @type {import(\"../../Tile.js\").default} */\n    let tile;\n\n    if (tileCache.containsKey(cacheKey)) {\n      tile = tileCache.get(cacheKey);\n    } else {\n      tile = tileSource.getTile(\n        z,\n        x,\n        y,\n        frameState.pixelRatio,\n        frameState.viewState.projection,\n      );\n      if (!tile) {\n        return null;\n      }\n      tileCache.set(cacheKey, tile);\n    }\n    return tile;\n  }\n\n  /**\n   * @param {number} z Tile coordinate z.\n   * @param {number} x Tile coordinate x.\n   * @param {number} y Tile coordinate y.\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @return {import(\"../../Tile.js\").default|null} Tile (or null if outside source extent).\n   * @protected\n   */\n  getTile(z, x, y, frameState) {\n    const tile = this.getOrCreateTile(z, x, y, frameState);\n    if (!tile) {\n      return null;\n    }\n    return tile;\n  }\n\n  /**\n   * @param {import(\"../../pixel.js\").Pixel} pixel Pixel.\n   * @return {Uint8ClampedArray} Data at the pixel location.\n   * @override\n   */\n  getData(pixel) {\n    const frameState = this.frameState;\n    if (!frameState) {\n      return null;\n    }\n\n    const layer = this.getLayer();\n    const coordinate = applyTransform(\n      frameState.pixelToCoordinateTransform,\n      pixel.slice(),\n    );\n\n    const layerExtent = layer.getExtent();\n    if (layerExtent) {\n      if (!containsCoordinate(layerExtent, coordinate)) {\n        return null;\n      }\n    }\n\n    const viewState = frameState.viewState;\n    const source = layer.getRenderSource();\n    const tileGrid = source.getTileGridForProjection(viewState.projection);\n    const tilePixelRatio = source.getTilePixelRatio(frameState.pixelRatio);\n\n    for (\n      let z = tileGrid.getZForResolution(viewState.resolution);\n      z >= tileGrid.getMinZoom();\n      --z\n    ) {\n      const tileCoord = tileGrid.getTileCoordForCoordAndZ(coordinate, z);\n      const tile = this.getTile(z, tileCoord[1], tileCoord[2], frameState);\n      if (!tile || tile.getState() !== TileState.LOADED) {\n        continue;\n      }\n\n      const tileOrigin = tileGrid.getOrigin(z);\n      const tileSize = toSize(tileGrid.getTileSize(z));\n      const tileResolution = tileGrid.getResolution(z);\n\n      /**\n       * @type {import('../../DataTile.js').ImageLike}\n       */\n      let image;\n      if (tile instanceof ImageTile || tile instanceof ReprojTile) {\n        image = tile.getImage();\n      } else if (tile instanceof DataTile) {\n        image = asImageLike(tile.getData());\n        if (!image) {\n          continue;\n        }\n      } else {\n        continue;\n      }\n\n      const col = Math.floor(\n        tilePixelRatio *\n          ((coordinate[0] - tileOrigin[0]) / tileResolution -\n            tileCoord[1] * tileSize[0]),\n      );\n\n      const row = Math.floor(\n        tilePixelRatio *\n          ((tileOrigin[1] - coordinate[1]) / tileResolution -\n            tileCoord[2] * tileSize[1]),\n      );\n\n      const gutter = Math.round(\n        tilePixelRatio * source.getGutterForProjection(viewState.projection),\n      );\n\n      return this.getImageData(image, col + gutter, row + gutter);\n    }\n\n    return null;\n  }\n\n  /**\n   * Determine whether render should be called.\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @return {boolean} Layer is ready to be rendered.\n   * @override\n   */\n  prepareFrame(frameState) {\n    if (!this.renderedProjection) {\n      this.renderedProjection = frameState.viewState.projection;\n    } else if (frameState.viewState.projection !== this.renderedProjection) {\n      this.tileCache_.clear();\n      this.renderedProjection = frameState.viewState.projection;\n    }\n\n    const source = this.getLayer().getSource();\n    if (!source) {\n      return false;\n    }\n    const sourceRevision = source.getRevision();\n    if (!this.renderedSourceRevision_) {\n      this.renderedSourceRevision_ = sourceRevision;\n    } else if (this.renderedSourceRevision_ !== sourceRevision) {\n      this.renderedSourceRevision_ = sourceRevision;\n      if (this.renderedSourceKey_ === source.getKey()) {\n        this.tileCache_.clear();\n      }\n    }\n    return true;\n  }\n\n  /**\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @param {import(\"../../extent.js\").Extent} extent The extent to be rendered.\n   * @param {number} initialZ The zoom level.\n   * @param {TileLookup} tilesByZ Lookup of tiles by zoom level.\n   * @param {number} preload Number of additional levels to load.\n   */\n  enqueueTiles(frameState, extent, initialZ, tilesByZ, preload) {\n    const viewState = frameState.viewState;\n    const tileLayer = this.getLayer();\n    const tileSource = tileLayer.getRenderSource();\n    const tileGrid = tileSource.getTileGridForProjection(viewState.projection);\n\n    const tileSourceKey = getUid(tileSource);\n    if (!(tileSourceKey in frameState.wantedTiles)) {\n      frameState.wantedTiles[tileSourceKey] = {};\n    }\n\n    const wantedTiles = frameState.wantedTiles[tileSourceKey];\n\n    const map = tileLayer.getMapInternal();\n    const minZ = Math.max(\n      initialZ - preload,\n      tileGrid.getMinZoom(),\n      tileGrid.getZForResolution(\n        Math.min(\n          tileLayer.getMaxResolution(),\n          map\n            ? map\n                .getView()\n                .getResolutionForZoom(Math.max(tileLayer.getMinZoom(), 0))\n            : tileGrid.getResolution(0),\n        ),\n        tileSource.zDirection,\n      ),\n    );\n    const rotation = viewState.rotation;\n    const viewport = rotation\n      ? getRotatedViewport(\n          viewState.center,\n          viewState.resolution,\n          rotation,\n          frameState.size,\n        )\n      : undefined;\n    for (let z = initialZ; z >= minZ; --z) {\n      const tileRange = tileGrid.getTileRangeForExtentAndZ(\n        extent,\n        z,\n        this.tempTileRange_,\n      );\n\n      const tileResolution = tileGrid.getResolution(z);\n\n      for (let x = tileRange.minX; x <= tileRange.maxX; ++x) {\n        for (let y = tileRange.minY; y <= tileRange.maxY; ++y) {\n          if (\n            rotation &&\n            !tileGrid.tileCoordIntersectsViewport([z, x, y], viewport)\n          ) {\n            continue;\n          }\n          const tile = this.getTile(z, x, y, frameState);\n          if (!tile) {\n            continue;\n          }\n          const added = addTileToLookup(tilesByZ, tile, z);\n          if (!added) {\n            continue;\n          }\n\n          const tileQueueKey = tile.getKey();\n          wantedTiles[tileQueueKey] = true;\n\n          if (tile.getState() === TileState.IDLE) {\n            if (!frameState.tileQueue.isKeyQueued(tileQueueKey)) {\n              const tileCoord = createTileCoord(z, x, y, this.tempTileCoord_);\n              frameState.tileQueue.enqueue([\n                tile,\n                tileSourceKey,\n                tileGrid.getTileCoordCenter(tileCoord),\n                tileResolution,\n              ]);\n            }\n          }\n        }\n      }\n    }\n  }\n\n  /**\n   * Look for tiles covering the provided tile coordinate at an alternate\n   * zoom level.  Loaded tiles will be added to the provided tile texture lookup.\n   * @param {import(\"../../tilecoord.js\").TileCoord} tileCoord The target tile coordinate.\n   * @param {TileLookup} tilesByZ Lookup of tiles by zoom level.\n   * @return {boolean} The tile coordinate is covered by loaded tiles at the alternate zoom level.\n   * @private\n   */\n  findStaleTile_(tileCoord, tilesByZ) {\n    const tileCache = this.tileCache_;\n    const z = tileCoord[0];\n    const x = tileCoord[1];\n    const y = tileCoord[2];\n    const staleKeys = this.getStaleKeys();\n    for (let i = 0; i < staleKeys.length; ++i) {\n      const cacheKey = getCacheKey(\n        this.getLayer().getSource(),\n        staleKeys[i],\n        z,\n        x,\n        y,\n      );\n      if (tileCache.containsKey(cacheKey)) {\n        const tile = tileCache.peek(cacheKey);\n        if (tile.getState() === TileState.LOADED) {\n          tile.endTransition(getUid(this));\n          addTileToLookup(tilesByZ, tile, z);\n          return true;\n        }\n      }\n    }\n    return false;\n  }\n\n  /**\n   * Look for tiles covering the provided tile coordinate at an alternate\n   * zoom level.  Loaded tiles will be added to the provided tile texture lookup.\n   * @param {import(\"../../tilegrid/TileGrid.js\").default} tileGrid The tile grid.\n   * @param {import(\"../../tilecoord.js\").TileCoord} tileCoord The target tile coordinate.\n   * @param {number} altZ The alternate zoom level.\n   * @param {TileLookup} tilesByZ Lookup of tiles by zoom level.\n   * @return {boolean} The tile coordinate is covered by loaded tiles at the alternate zoom level.\n   * @private\n   */\n  findAltTiles_(tileGrid, tileCoord, altZ, tilesByZ) {\n    const tileRange = tileGrid.getTileRangeForTileCoordAndZ(\n      tileCoord,\n      altZ,\n      this.tempTileRange_,\n    );\n\n    if (!tileRange) {\n      return false;\n    }\n\n    let covered = true;\n    const tileCache = this.tileCache_;\n    const source = this.getLayer().getRenderSource();\n    const sourceKey = source.getKey();\n    for (let x = tileRange.minX; x <= tileRange.maxX; ++x) {\n      for (let y = tileRange.minY; y <= tileRange.maxY; ++y) {\n        const cacheKey = getCacheKey(source, sourceKey, altZ, x, y);\n        let loaded = false;\n        if (tileCache.containsKey(cacheKey)) {\n          const tile = tileCache.peek(cacheKey);\n          if (tile.getState() === TileState.LOADED) {\n            addTileToLookup(tilesByZ, tile, altZ);\n            loaded = true;\n          }\n        }\n        if (!loaded) {\n          covered = false;\n        }\n      }\n    }\n    return covered;\n  }\n\n  /**\n   * Render the layer.\n   *\n   * The frame rendering logic has three parts:\n   *\n   *  1. Enqueue tiles\n   *  2. Find alt tiles for those that are not yet loaded\n   *  3. Render loaded tiles\n   *\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @param {HTMLElement} target Target that may be used to render content to.\n   * @return {HTMLElement} The rendered element.\n   * @override\n   */\n  renderFrame(frameState, target) {\n    this.renderComplete = true;\n\n    /**\n     * TODO:\n     *  maybe skip transition when not fully opaque\n     *  decide if this.renderComplete is useful\n     */\n\n    const layerState = frameState.layerStatesArray[frameState.layerIndex];\n    const viewState = frameState.viewState;\n    const projection = viewState.projection;\n    const viewResolution = viewState.resolution;\n    const viewCenter = viewState.center;\n    const pixelRatio = frameState.pixelRatio;\n\n    const tileLayer = this.getLayer();\n    const tileSource = tileLayer.getSource();\n    const tileGrid = tileSource.getTileGridForProjection(projection);\n    const z = tileGrid.getZForResolution(viewResolution, tileSource.zDirection);\n    const tileResolution = tileGrid.getResolution(z);\n\n    const sourceKey = tileSource.getKey();\n    if (!this.renderedSourceKey_) {\n      this.renderedSourceKey_ = sourceKey;\n    } else if (this.renderedSourceKey_ !== sourceKey) {\n      this.prependStaleKey(this.renderedSourceKey_);\n      this.renderedSourceKey_ = sourceKey;\n    }\n\n    let frameExtent = frameState.extent;\n    const tilePixelRatio = tileSource.getTilePixelRatio(pixelRatio);\n\n    this.prepareContainer(frameState, target);\n\n    // desired dimensions of the canvas in pixels\n    const width = this.context.canvas.width;\n    const height = this.context.canvas.height;\n\n    const layerExtent =\n      layerState.extent && fromUserExtent(layerState.extent, projection);\n    if (layerExtent) {\n      frameExtent = getIntersection(\n        frameExtent,\n        fromUserExtent(layerState.extent, projection),\n      );\n    }\n\n    const dx = (tileResolution * width) / 2 / tilePixelRatio;\n    const dy = (tileResolution * height) / 2 / tilePixelRatio;\n    const canvasExtent = [\n      viewCenter[0] - dx,\n      viewCenter[1] - dy,\n      viewCenter[0] + dx,\n      viewCenter[1] + dy,\n    ];\n\n    /**\n     * @type {TileLookup}\n     */\n    const tilesByZ = {};\n\n    this.renderedTiles.length = 0;\n\n    /**\n     * Part 1: Enqueue tiles\n     */\n\n    const preload = tileLayer.getPreload();\n    if (frameState.nextExtent) {\n      const targetZ = tileGrid.getZForResolution(\n        viewState.nextResolution,\n        tileSource.zDirection,\n      );\n      const nextExtent = getRenderExtent(frameState, frameState.nextExtent);\n      this.enqueueTiles(frameState, nextExtent, targetZ, tilesByZ, preload);\n    }\n\n    const renderExtent = getRenderExtent(frameState, frameExtent);\n    this.enqueueTiles(frameState, renderExtent, z, tilesByZ, 0);\n    if (preload > 0) {\n      setTimeout(() => {\n        this.enqueueTiles(\n          frameState,\n          renderExtent,\n          z - 1,\n          tilesByZ,\n          preload - 1,\n        );\n      }, 0);\n    }\n\n    if (!(z in tilesByZ)) {\n      return this.container;\n    }\n\n    /**\n     * Part 2: Find alt tiles for those that are not yet loaded\n     */\n\n    const uid = getUid(this);\n    const time = frameState.time;\n\n    // look for cached tiles to use if a target tile is not ready\n    for (const tile of tilesByZ[z]) {\n      const tileState = tile.getState();\n      if (tileState === TileState.EMPTY) {\n        continue;\n      }\n      const tileCoord = tile.tileCoord;\n\n      if (tileState === TileState.LOADED) {\n        const alpha = tile.getAlpha(uid, time);\n        if (alpha === 1) {\n          // no need to look for alt tiles\n          tile.endTransition(uid);\n          continue;\n        }\n      }\n      if (tileState !== TileState.ERROR) {\n        this.renderComplete = false;\n      }\n\n      const hasStaleTile = this.findStaleTile_(tileCoord, tilesByZ);\n      if (hasStaleTile) {\n        // use the stale tile before the new tile's transition has completed\n        removeTileFromLookup(tilesByZ, tile, z);\n        frameState.animate = true;\n        continue;\n      }\n\n      // first look for child tiles (at z + 1)\n      const coveredByChildren = this.findAltTiles_(\n        tileGrid,\n        tileCoord,\n        z + 1,\n        tilesByZ,\n      );\n\n      if (coveredByChildren) {\n        continue;\n      }\n\n      // next look for parent tiles\n      const minZoom = tileGrid.getMinZoom();\n      for (let parentZ = z - 1; parentZ >= minZoom; --parentZ) {\n        const coveredByParent = this.findAltTiles_(\n          tileGrid,\n          tileCoord,\n          parentZ,\n          tilesByZ,\n        );\n\n        if (coveredByParent) {\n          break;\n        }\n      }\n    }\n\n    /**\n     * Part 3: Render loaded tiles\n     */\n\n    const canvasScale =\n      ((tileResolution / viewResolution) * pixelRatio) / tilePixelRatio;\n\n    const context = this.getRenderContext(frameState);\n\n    // set scale transform for calculating tile positions on the canvas\n    composeTransform(\n      this.tempTransform,\n      width / 2,\n      height / 2,\n      canvasScale,\n      canvasScale,\n      0,\n      -width / 2,\n      -height / 2,\n    );\n\n    if (layerState.extent) {\n      this.clipUnrotated(context, frameState, layerExtent);\n    }\n\n    if (!tileSource.getInterpolate()) {\n      context.imageSmoothingEnabled = false;\n    }\n\n    this.preRender(context, frameState);\n\n    /** @type {Array<number>} */\n    const zs = Object.keys(tilesByZ).map(Number);\n    zs.sort(ascending);\n\n    let currentClip;\n    const clips = [];\n    const clipZs = [];\n    for (let i = zs.length - 1; i >= 0; --i) {\n      const currentZ = zs[i];\n      const currentTilePixelSize = tileSource.getTilePixelSize(\n        currentZ,\n        pixelRatio,\n        projection,\n      );\n      const currentResolution = tileGrid.getResolution(currentZ);\n      const currentScale = currentResolution / tileResolution;\n      const dx = currentTilePixelSize[0] * currentScale * canvasScale;\n      const dy = currentTilePixelSize[1] * currentScale * canvasScale;\n      const originTileCoord = tileGrid.getTileCoordForCoordAndZ(\n        getTopLeft(canvasExtent),\n        currentZ,\n      );\n      const originTileExtent = tileGrid.getTileCoordExtent(originTileCoord);\n      const origin = applyTransform(this.tempTransform, [\n        (tilePixelRatio * (originTileExtent[0] - canvasExtent[0])) /\n          tileResolution,\n        (tilePixelRatio * (canvasExtent[3] - originTileExtent[3])) /\n          tileResolution,\n      ]);\n      const tileGutter =\n        tilePixelRatio * tileSource.getGutterForProjection(projection);\n      for (const tile of tilesByZ[currentZ]) {\n        if (tile.getState() !== TileState.LOADED) {\n          continue;\n        }\n        const tileCoord = tile.tileCoord;\n\n        // Calculate integer positions and sizes so that tiles align\n        const xIndex = originTileCoord[1] - tileCoord[1];\n        const nextX = Math.round(origin[0] - (xIndex - 1) * dx);\n        const yIndex = originTileCoord[2] - tileCoord[2];\n        const nextY = Math.round(origin[1] - (yIndex - 1) * dy);\n        const x = Math.round(origin[0] - xIndex * dx);\n        const y = Math.round(origin[1] - yIndex * dy);\n        const w = nextX - x;\n        const h = nextY - y;\n        const transition = zs.length === 1;\n\n        let contextSaved = false;\n\n        // Clip mask for regions in this tile that already filled by a higher z tile\n        currentClip = [x, y, x + w, y, x + w, y + h, x, y + h];\n        for (let i = 0, ii = clips.length; i < ii; ++i) {\n          if (!transition && currentZ < clipZs[i]) {\n            const clip = clips[i];\n            if (\n              intersects(\n                [x, y, x + w, y + h],\n                [clip[0], clip[3], clip[4], clip[7]],\n              )\n            ) {\n              if (!contextSaved) {\n                context.save();\n                contextSaved = true;\n              }\n              context.beginPath();\n              // counter-clockwise (outer ring) for current tile\n              context.moveTo(currentClip[0], currentClip[1]);\n              context.lineTo(currentClip[2], currentClip[3]);\n              context.lineTo(currentClip[4], currentClip[5]);\n              context.lineTo(currentClip[6], currentClip[7]);\n              // clockwise (inner ring) for higher z tile\n              context.moveTo(clip[6], clip[7]);\n              context.lineTo(clip[4], clip[5]);\n              context.lineTo(clip[2], clip[3]);\n              context.lineTo(clip[0], clip[1]);\n              context.clip();\n            }\n          }\n        }\n        clips.push(currentClip);\n        clipZs.push(currentZ);\n\n        this.drawTile(tile, frameState, x, y, w, h, tileGutter, transition);\n        if (contextSaved) {\n          context.restore();\n        }\n        this.renderedTiles.unshift(tile);\n\n        // TODO: decide if this is necessary\n        this.updateUsedTiles(frameState.usedTiles, tileSource, tile);\n      }\n    }\n\n    this.renderedResolution = tileResolution;\n    this.extentChanged =\n      !this.renderedExtent_ || !equals(this.renderedExtent_, canvasExtent);\n    this.renderedExtent_ = canvasExtent;\n    this.renderedPixelRatio = pixelRatio;\n\n    this.postRender(this.context, frameState);\n\n    if (layerState.extent) {\n      context.restore();\n    }\n    context.imageSmoothingEnabled = true;\n\n    if (this.renderComplete) {\n      /**\n       * @param {import(\"../../Map.js\").default} map Map.\n       * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n       */\n      const postRenderFunction = (map, frameState) => {\n        const tileSourceKey = getUid(tileSource);\n        const wantedTiles = frameState.wantedTiles[tileSourceKey];\n        const tilesCount = wantedTiles ? Object.keys(wantedTiles).length : 0;\n        this.updateCacheSize(tilesCount);\n        this.tileCache_.expireCache();\n      };\n\n      frameState.postRenderFunctions.push(postRenderFunction);\n    }\n\n    return this.container;\n  }\n\n  /**\n   * Increases the cache size if needed\n   * @param {number} tileCount Minimum number of tiles needed.\n   */\n  updateCacheSize(tileCount) {\n    this.tileCache_.highWaterMark = Math.max(\n      this.tileCache_.highWaterMark,\n      tileCount * 2,\n    );\n  }\n\n  /**\n   * @param {import(\"../../Tile.js\").default} tile Tile.\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @param {number} x Left of the tile.\n   * @param {number} y Top of the tile.\n   * @param {number} w Width of the tile.\n   * @param {number} h Height of the tile.\n   * @param {number} gutter Tile gutter.\n   * @param {boolean} transition Apply an alpha transition.\n   * @protected\n   */\n  drawTile(tile, frameState, x, y, w, h, gutter, transition) {\n    let image;\n    if (tile instanceof DataTile) {\n      image = asImageLike(tile.getData());\n      if (!image) {\n        throw new Error('Rendering array data is not yet supported');\n      }\n    } else {\n      image = this.getTileImage(\n        /** @type {import(\"../../ImageTile.js\").default} */ (tile),\n      );\n    }\n    if (!image) {\n      return;\n    }\n    const context = this.getRenderContext(frameState);\n    const uid = getUid(this);\n    const layerState = frameState.layerStatesArray[frameState.layerIndex];\n    const alpha =\n      layerState.opacity *\n      (transition ? tile.getAlpha(uid, frameState.time) : 1);\n    const alphaChanged = alpha !== context.globalAlpha;\n    if (alphaChanged) {\n      context.save();\n      context.globalAlpha = alpha;\n    }\n    context.drawImage(\n      image,\n      gutter,\n      gutter,\n      image.width - 2 * gutter,\n      image.height - 2 * gutter,\n      x,\n      y,\n      w,\n      h,\n    );\n\n    if (alphaChanged) {\n      context.restore();\n    }\n    if (alpha !== layerState.opacity) {\n      frameState.animate = true;\n    } else if (transition) {\n      tile.endTransition(uid);\n    }\n  }\n\n  /**\n   * @return {HTMLCanvasElement} Image\n   */\n  getImage() {\n    const context = this.context;\n    return context ? context.canvas : null;\n  }\n\n  /**\n   * Get the image from a tile.\n   * @param {import(\"../../ImageTile.js\").default} tile Tile.\n   * @return {HTMLCanvasElement|HTMLImageElement|HTMLVideoElement} Image.\n   * @protected\n   */\n  getTileImage(tile) {\n    return tile.getImage();\n  }\n\n  /**\n   * @param {!Object<string, !Object<string, boolean>>} usedTiles Used tiles.\n   * @param {import(\"../../source/Tile.js\").default} tileSource Tile source.\n   * @param {import('../../Tile.js').default} tile Tile.\n   * @protected\n   */\n  updateUsedTiles(usedTiles, tileSource, tile) {\n    // FIXME should we use tilesToDrawByZ instead?\n    const tileSourceKey = getUid(tileSource);\n    if (!(tileSourceKey in usedTiles)) {\n      usedTiles[tileSourceKey] = {};\n    }\n    usedTiles[tileSourceKey][tile.getKey()] = true;\n  }\n}\n\nexport default CanvasTileLayerRenderer;\n", "/**\n * @module ol/layer/TileProperty\n */\n\n/**\n * @enum {string}\n */\nexport default {\n  PRELOAD: 'preload',\n  USE_INTERIM_TILES_ON_ERROR: 'useInterimTilesOnError',\n};\n", "/**\n * @module ol/layer/BaseTile\n */\nimport Layer from './Layer.js';\nimport TileProperty from './TileProperty.js';\n\n/***\n * @template Return\n * @typedef {import(\"../Observable\").OnSignature<import(\"../Observable\").EventTypes, import(\"../events/Event.js\").default, Return> &\n *   import(\"../Observable\").OnSignature<import(\"./Base\").BaseLayerObjectEventTypes|\n *     import(\"./Layer.js\").LayerEventType|'change:preload'|'change:useInterimTilesOnError', import(\"../Object\").ObjectEvent, Return> &\n *   import(\"../Observable\").OnSignature<import(\"../render/EventType\").LayerRenderEventTypes, import(\"../render/Event\").default, Return> &\n *   import(\"../Observable\").CombinedOnSignature<import(\"../Observable\").EventTypes|import(\"./Base\").BaseLayerObjectEventTypes|\n *   import(\"./Layer.js\").LayerEventType|'change:preload'|'change:useInterimTilesOnError'|import(\"../render/EventType\").LayerRenderEventTypes, Return>} BaseTileLayerOnSignature\n */\n\n/**\n * @template {import(\"../source/Tile.js\").default} TileSourceType\n * @typedef {Object} Options\n * @property {string} [className='ol-layer'] A CSS class name to set to the layer element.\n * @property {number} [opacity=1] Opacity (0, 1).\n * @property {boolean} [visible=true] Visibility.\n * @property {import(\"../extent.js\").Extent} [extent] The bounding extent for layer rendering.  The layer will not be\n * rendered outside of this extent.\n * @property {number} [zIndex] The z-index for layer rendering.  At rendering time, the layers\n * will be ordered, first by Z-index and then by position. When `undefined`, a `zIndex` of 0 is assumed\n * for layers that are added to the map's `layers` collection, or `Infinity` when the layer's `setMap()`\n * method was used.\n * @property {number} [minResolution] The minimum resolution (inclusive) at which this layer will be\n * visible.\n * @property {number} [maxResolution] The maximum resolution (exclusive) below which this layer will\n * be visible.\n * @property {number} [minZoom] The minimum view zoom level (exclusive) above which this layer will be\n * visible.\n * @property {number} [maxZoom] The maximum view zoom level (inclusive) at which this layer will\n * be visible.\n * @property {number} [preload=0] Preload. Load low-resolution tiles up to `preload` levels. `0`\n * means no preloading.\n * @property {TileSourceType} [source] Source for this layer.\n * @property {import(\"../Map.js\").default} [map] Sets the layer as overlay on a map. The map will not manage\n * this layer in its layers collection, and the layer will be rendered on top. This is useful for\n * temporary layers. The standard way to add a layer to a map and have it managed by the map is to\n * use {@link import(\"../Map.js\").default#addLayer map.addLayer()}.\n * @property {import(\"./Base.js\").BackgroundColor} [background] Background color for the layer. If not specified, no background\n * will be rendered.\n * @property {boolean} [useInterimTilesOnError=true] Deprecated.  Use interim tiles on error.\n * @property {Object<string, *>} [properties] Arbitrary observable properties. Can be accessed with `#get()` and `#set()`.\n * @property {number} [cacheSize=512] The internal tile cache size.  This needs to be large enough to render\n * two zoom levels worth of tiles.\n */\n\n/**\n * @classdesc\n * For layer sources that provide pre-rendered, tiled images in grids that are\n * organized by zoom levels for specific resolutions.\n * Note that any property set in the options is set as a {@link module:ol/Object~BaseObject}\n * property on the layer object; for example, setting `title: 'My Title'` in the\n * options means that `title` is observable, and has get/set accessors.\n *\n * @template {import(\"../source/Tile.js\").default} TileSourceType\n * @template {import(\"../renderer/Layer.js\").default} RendererType\n * @extends {Layer<TileSourceType, RendererType>}\n * @api\n */\nclass BaseTileLayer extends Layer {\n  /**\n   * @param {Options<TileSourceType>} [options] Tile layer options.\n   */\n  constructor(options) {\n    options = options ? options : {};\n\n    const baseOptions = Object.assign({}, options);\n\n    const cacheSize = options.cacheSize;\n    delete options.cacheSize;\n\n    delete baseOptions.preload;\n    delete baseOptions.useInterimTilesOnError;\n    super(baseOptions);\n\n    /***\n     * @type {BaseTileLayerOnSignature<import(\"../events\").EventsKey>}\n     */\n    this.on;\n\n    /***\n     * @type {BaseTileLayerOnSignature<import(\"../events\").EventsKey>}\n     */\n    this.once;\n\n    /***\n     * @type {BaseTileLayerOnSignature<void>}\n     */\n    this.un;\n\n    /**\n     * @type {number|undefined}\n     * @private\n     */\n    this.cacheSize_ = cacheSize;\n\n    this.setPreload(options.preload !== undefined ? options.preload : 0);\n    this.setUseInterimTilesOnError(\n      options.useInterimTilesOnError !== undefined\n        ? options.useInterimTilesOnError\n        : true,\n    );\n  }\n\n  /**\n   * @return {number|undefined} The suggested cache size\n   * @protected\n   */\n  getCacheSize() {\n    return this.cacheSize_;\n  }\n\n  /**\n   * Return the level as number to which we will preload tiles up to.\n   * @return {number} The level to preload tiles up to.\n   * @observable\n   * @api\n   */\n  getPreload() {\n    return /** @type {number} */ (this.get(TileProperty.PRELOAD));\n  }\n\n  /**\n   * Set the level as number to which we will preload tiles up to.\n   * @param {number} preload The level to preload tiles up to.\n   * @observable\n   * @api\n   */\n  setPreload(preload) {\n    this.set(TileProperty.PRELOAD, preload);\n  }\n\n  /**\n   * Deprecated.  Whether we use interim tiles on error.\n   * @return {boolean} Use interim tiles on error.\n   * @observable\n   * @api\n   */\n  getUseInterimTilesOnError() {\n    return /** @type {boolean} */ (\n      this.get(TileProperty.USE_INTERIM_TILES_ON_ERROR)\n    );\n  }\n\n  /**\n   * Deprecated.  Set whether we use interim tiles on error.\n   * @param {boolean} useInterimTilesOnError Use interim tiles on error.\n   * @observable\n   * @api\n   */\n  setUseInterimTilesOnError(useInterimTilesOnError) {\n    this.set(TileProperty.USE_INTERIM_TILES_ON_ERROR, useInterimTilesOnError);\n  }\n\n  /**\n   * Get data for a pixel location.  The return type depends on the source data.  For image tiles,\n   * a four element RGBA array will be returned.  For data tiles, the array length will match the\n   * number of bands in the dataset.  For requests outside the layer extent, `null` will be returned.\n   * Data for a image tiles can only be retrieved if the source's `crossOrigin` property is set.\n   *\n   * ```js\n   * // display layer data on every pointer move\n   * map.on('pointermove', (event) => {\n   *   console.log(layer.getData(event.pixel));\n   * });\n   * ```\n   * @param {import(\"../pixel\").Pixel} pixel Pixel.\n   * @return {Uint8ClampedArray|Uint8Array|Float32Array|DataView|null} Pixel data.\n   * @api\n   * @override\n   */\n  getData(pixel) {\n    return super.getData(pixel);\n  }\n}\n\nexport default BaseTileLayer;\n", "/**\n * @module ol/layer/Tile\n */\nimport CanvasTileLayerRenderer from '../renderer/canvas/TileLayer.js';\nimport BaseTileLayer from './BaseTile.js';\n\n/**\n * @classdesc\n * For layer sources that provide pre-rendered, tiled images in grids that are\n * organized by zoom levels for specific resolutions.\n * Note that any property set in the options is set as a {@link module:ol/Object~BaseObject}\n * property on the layer object; for example, setting `title: 'My Title'` in the\n * options means that `title` is observable, and has get/set accessors.\n *\n * @template {import(\"../source/Tile.js\").default} [TileSourceType=import(\"../source/Tile.js\").default]\n * @extends BaseTileLayer<TileSourceType, CanvasTileLayerRenderer>\n * @api\n */\nclass TileLayer extends BaseTileLayer {\n  /**\n   * @param {import(\"./BaseTile.js\").Options<TileSourceType>} [options] Tile layer options.\n   */\n  constructor(options) {\n    super(options);\n  }\n\n  /**\n   * @override\n   */\n  createRenderer() {\n    return new CanvasTileLayerRenderer(this, {\n      cacheSize: this.getCacheSize(),\n    });\n  }\n}\n\nexport default TileLayer;\n"],
  "mappings": "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",
  "names": ["init_Tile", "Tile_default", "dx", "dy", "i", "frameState", "init_Layer", "Layer_default", "Tile_default", "init_Tile"]
}
